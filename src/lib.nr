// Ethereum trie proof implementation
use dep::std::hash::keccak256;

mod rlp; // Module for required RLP encoding/decoding

// 2-node enum
global EXTENSION: Field = 0;
global LEAF: Field = 1;

// Constants for 32-byte long keys; TODO: Omit these when it is possible to replace constants with numeric generics.
global KEY_LENGTH: Field = 32; // key length in bytes; <= 55 for simplicity
global NIBBLE_LENGTH: Field = 64; // = 2*KEY_LENGTH

// For tries with 32-byte long keys, we we can bound the byte length of any node from above by the following constant:
global MAX_TRIE_NODE_LENGTH: Field = 532; // = MAX_RLP_LIST_HEADER_LENGTH (= 1 + MAX_LENGTH_BYTES)
//   + 16*MAX_RLP_ELEMENT_LENGTH (= 16*(1 + KEY_LENGTH))
// + LENGTH_OF_NULL_ELEMENT (= 1)

global MAX_ACCOUNT_STATE_LENGTH: Field = 134;

global MAX_NUM_FIELDS: Field = 17;

// Type for storage proofs corresponding to `ethers-rs` StorageProof type
// Involves 32-byte keys
// TODO: Add comptime Field parameters to
// - bound the sizes of the nodes embedded in `proof` to allow arbitrary fixed-length keys
// - bound the key length to allow variable-length keys
// These would require the ability to declare arrays of length expressed as a comptime Field variable.
struct TrieProof<KEY_LEN, PROOF_LEN, VALUE_LEN> // VALUE_LEN should be smaller than 56 bytes.
{
    key: [u8; KEY_LEN], // Unhashed key to look up along proof path
    proof: [u8; PROOF_LEN], // RLP encoded proof path; assumed to be obtained by appropriately right-padding each node (e.g. with zeros) and concatenating in order. The size of each node will depend on the application, e.g. MAX_TRIE_NODE_LENGTH for storage proofs.
    depth: Field, // Depth of proof. Necessary for technical reasons
    value: [u8; VALUE_LEN]
}

impl<PROOF_LEN, VALUE_LEN> TrieProof<32, PROOF_LEN, VALUE_LEN>
{
    // Ethereum storage trie proof verifier
    fn verify_storage_root( // PROOF_LEN *must* be a multiple of MAX_TRIE_NODE_LENGTH!
        self,
        trie_root: [u8; KEY_LENGTH], // Hash of root, i.e. first, node.
    ) -> bool
    {
        assert((PROOF_LEN as u32) % (MAX_TRIE_NODE_LENGTH as u32) == 0); // Check that N is a multiple of MAX_TRIE_NODE_LENGTH

        let key = keccak256(self.key, 32); // The path is traced out by the hashed key
        
        let key_nibbles: [u4; NIBBLE_LENGTH] = key_as_nibbles(key);
        
        let mut key_ptr = 0;

        let (value, mut value_length) = byte_value(self.value); // Value to verify together with its byte length

        let path = self.proof; // Proof path

        let depth = self.depth; // Depth of proof path

        let mut extracted_hash = trie_root;

        let mut node = [0; MAX_TRIE_NODE_LENGTH];

        for i in 0..(path.len()/MAX_TRIE_NODE_LENGTH - 1)
        {
            let range_p = (i as u8) < (depth - 1) as u8; // Range predicate
            
            let k = if (range_p) {i} else {0}; // Restrict index to range {0, ..., depth - 2}

            // Populate node array
	        for j in 0..MAX_TRIE_NODE_LENGTH
	        {
		        node[j] = path[j + k*MAX_TRIE_NODE_LENGTH];
	        }

            assert(!range_p | verify_node_hash(node, extracted_hash)); // If within range, node hash should match the hash extracted from the preceding node.
            
 	        let lookup: ([u8; 32], Field) = resolve_nibble32(key_nibbles, key_ptr, node); // Resolve next nibble(s)

            // Extract hash and advance key pointer if within range
            if range_p
            {
                extracted_hash = lookup.0;
                key_ptr = lookup.1;
            }
        }
        
        // Treat final node as the preceding nodes...
        for j in 0..MAX_TRIE_NODE_LENGTH
	    {
		    node[j] = path[j + (depth - 1)*MAX_TRIE_NODE_LENGTH];
	    }

        assert(verify_node_hash(node, extracted_hash));

        let rlp_list: rlp::RLP_List<MAX_NUM_FIELDS> = rlp::decode1_small_lis(node); // Both slots contain less than 56 bytes.
        
        // ...except extract a value rather than a key.
 	    let (mut extracted_value, extracted_value_length, terminal_key_ptr): ([u8; VALUE_LEN], Field, Field) = resolve2(LEAF, node, rlp_list, key_nibbles, key_ptr);

        assert((extracted_value_length as u32) <= (VALUE_LEN as u32)); // Extracted value should fit in a byte array of length VALUE_LEN.
 	    key_ptr = terminal_key_ptr;

        assert(key_ptr == 2*key.len()); // All of the key has been exhausted.

        // // Decode extracted value
        let (dec_value_offset, dec_value_len) = rlp::decode0(extracted_value);
        assert(dec_value_len == value_length);
        dep::std::println(dec_value_len);
        
        for i in 0..VALUE_LEN
        {
            if (i as u32) < (value_length as u32)
            {
                assert(extracted_value[dec_value_offset + i] == value[i]);
            }
        }
        
        true
    }
}

impl<PROOF_LEN, VALUE_LEN> TrieProof<20, PROOF_LEN, VALUE_LEN>
{
    // Ethereum state trie proof verifier
    fn verify_state_root( // PROOF_LEN *must* be a multiple of MAX_TRIE_NODE_LENGTH!
        self,
        trie_root: [u8; KEY_LENGTH], // Hash of root, i.e. first, node.
    ) -> bool
    {
        assert((PROOF_LEN as u32) % (MAX_TRIE_NODE_LENGTH as u32) == 0); // Check that N is a multiple of MAX_TRIE_NODE_LENGTH

        let key = keccak256(self.key, 20); // The path is traced out by the hashed key
        
        let key_nibbles: [u4; NIBBLE_LENGTH] = key_as_nibbles(key);
        
        let mut key_ptr = 0;

        let (value, mut value_length) = byte_value(self.value); // Value to verify together with its byte length

        let path = self.proof; // Proof path

        let depth = self.depth; // Depth of proof path

        let mut extracted_hash = trie_root;

        let mut node = [0; MAX_TRIE_NODE_LENGTH];

        for i in 0..(path.len()/MAX_TRIE_NODE_LENGTH - 1)
        {
            let range_p = (i as u8) < (depth - 1) as u8; // Range predicate
            
            let k = if (range_p) {i} else {0}; // Restrict index to range {0, ..., depth - 2}

            // Populate node array
	        for j in 0..MAX_TRIE_NODE_LENGTH
	        {
		        node[j] = path[j + k*MAX_TRIE_NODE_LENGTH];
	        }

            assert(!range_p | verify_node_hash(node, extracted_hash)); // If within range, node hash should match the hash extracted from the preceding node.
            
 	        let lookup: ([u8; 32], Field) = resolve_nibble32(key_nibbles, key_ptr, node); // Resolve next nibble(s)

            // Extract hash and advance key pointer if within range
            if range_p
            {
                extracted_hash = lookup.0;
                key_ptr = lookup.1;
            }
        }
        
        // Treat final node as the preceding nodes...
        for j in 0..MAX_TRIE_NODE_LENGTH
	    {
		    node[j] = path[j + (depth - 1)*MAX_TRIE_NODE_LENGTH];
	    }

        assert(verify_node_hash(node, extracted_hash));

        let rlp_list: rlp::RLP_List<MAX_NUM_FIELDS> = rlp::decode1(node); // TODO: For storage proofs, replace with decode1_small_lis
        
        // ...except extract a value rather than a key.
 	    let (mut extracted_value, extracted_value_length, terminal_key_ptr): ([u8; VALUE_LEN], Field, Field) = resolve2(LEAF, node, rlp_list, key_nibbles, key_ptr);

        assert((extracted_value_length as u32) <= (VALUE_LEN as u32)); // Extracted value should fit in a byte array of length VALUE_LEN.
 	    key_ptr = terminal_key_ptr;

        assert(key_ptr == 2*key.len()); // All of the key has been exhausted.

        // No need to decode data, but it ought to be a list.
        assert(extracted_value[0] >= 0xc0);

        assert(extracted_value_length == value_length);
        for i in 0..VALUE_LEN
        {
            if (i as u32) < (value_length as u32)
            {
                assert(extracted_value[i] == value[i]);
            }
        }
        
        true
    }
}

// Verify Keccak hash of node
fn verify_node_hash<N>(node: [u8; N], hash: [u8; 32])
                       -> bool
{
    // Extract actual length of node
    let node_length = { let rlp_header = rlp::decode_len(node); rlp_header.offset + rlp_header.length } as u32; // Determine length of node

    // Compute Keccak256 hash of node
	let node_hash = keccak256(node, node_length);

    // Compare hashes
	node_hash == hash
}


// Key-to-nibble conversion
fn key_as_nibbles<KEY_LEN, NIB_LEN>(key: [u8; KEY_LEN]) -> [u4; NIB_LEN]
{
    assert(NIB_LEN == 2*KEY_LEN);
    
    let mut nibkey = [0; NIB_LEN];
    
    for i in 0..KEY_LEN
    {
	    nibkey[2*i + 1] = (key[i] & 0x0f) as u4;
	    nibkey[2*i] = ((key[i] - nibkey[2*i + 1] as u8) >> 4) as u4;
    }
    
    nibkey
}

// Decode leaf/extension node's first slot into nibbles
// Returns nibbles in a right-padded array together with the number of nibbles.
fn compact_decode<MAX_ENC_LEN, NIB_LEN>(input: [u8; MAX_ENC_LEN], length: Field) -> ([u4; NIB_LEN], Field)
{

    assert((2 as u32)*(MAX_ENC_LEN as u32) <= ((NIB_LEN + 2) as u32)); // MAX_ENC_LEN should be NIB_LEN/2 or NIB_LEN/2 + 1. TODO
    
    let mut nibble = [0 as u4; NIB_LEN];
    let mut out_length = 0;

	let mut prev_nibbles = ((input[0] >> 4) as u4, (input[0] & 0x0f) as u4);
    let mut cur_nibbles = (0,0);
    
    let first_nibble = prev_nibbles.0;
	let parity = first_nibble as u1;

    // Consistency checks
    // The first nibble should always be less than 4.
    assert(first_nibble < 4);
    // Parity consistency: If we are dealing with an even number of nibbles, then the second nibble should be 0.
    assert(((1-parity) as u4)*prev_nibbles.1 == 0);

    for i in 0..(MAX_ENC_LEN - 1)
    {
        let x = input[i + 1];
        cur_nibbles = ((x >> 4) as u4, (x & 0x0f) as u4); // x decomposed into two nibbles

        nibble[2*i] = (parity as u4)*prev_nibbles.1 + (1 - (parity as u4))*cur_nibbles.0;
        nibble[2*i + 1] = (parity as u4)*cur_nibbles.0 + (1 - (parity as u4))*cur_nibbles.1;

        prev_nibbles = cur_nibbles;
    }

	out_length = 2*length + (parity as Field) - 2;


    assert((out_length as u32) <= (NIB_LEN as u32)); // Sanity check
    let out = (nibble, out_length);
    out
}

// Resolve nibble (or sequence of nibbles) in RLP-encoded node
// Assumes 32-byte key length
fn resolve_nibble32<N>(
    key: [u4; NIBBLE_LENGTH],
    mut key_ptr: Field,
    node: [u8; N]) ->
    ([u8; 32], // Extracted key
    Field) // New key pointer
{
    let rlp_list: rlp::RLP_List<MAX_NUM_FIELDS> = rlp::decode1_small_lis(node); // Assumes no intermediate nodes have slots with >= 56 bytes, which is the case for state and storage proofs.
    let num_fields = rlp_list.num_fields;

    let mut resolved_key = [0; 32];
    let mut resolved_key_length = 0;
    
    if num_fields == 2 // If we are dealing with a leaf/extension node
    {
        // Resolve 2-node
        let node_resolution: ([u8; 32], Field, Field) = resolve2(EXTENSION, node, rlp_list, key, key_ptr);
        // Deconstruct
        key_ptr = node_resolution.2;
        resolved_key = node_resolution.0;
        resolved_key_length = node_resolution.1;        
    }
    else
    {
        // Since we are dealing with a fixed key length, the last slot must be empty.
        assert(rlp_list.length[16] == 0);

        // Resolve 17-node
        let node_resolution = resolve17(node, rlp_list, key, key_ptr);

        key_ptr = node_resolution.2;
        resolved_key = node_resolution.0;
        resolved_key_length = node_resolution.1;
	}

    assert(resolved_key_length == 32);
    
    (resolved_key, key_ptr)
}

// Resolve a 17-node, i.e. a BRANCH.
fn resolve17<N>(
    node: [u8; N],
    rlp_list: rlp::RLP_List<MAX_NUM_FIELDS>,
    key: [u4; NIBBLE_LENGTH],
    mut key_ptr: Field)
                      -> (
    [u8; KEY_LENGTH], // Extracted key
    Field, // Extracted key length
    Field) // New key pointer
{
    // We should be dealing with a node containing 17 elements
    assert(rlp_list.num_fields == 17);
    
    // The first 16 slots should be of length 32 or 0.
    for i in 0..16
    {
        assert(rlp_list.length[i]*(rlp_list.length[i] - KEY_LENGTH) == 0);
    }

    
    let cur_nibble = key[key_ptr];
	let resolved_key_length = rlp_list.length[cur_nibble as Field];

    assert(resolved_key_length == KEY_LENGTH);
    assert((key_ptr as u32) < (NIBBLE_LENGTH as u32)); // Fixed-length key => Node cannot be terminal.
    
    key_ptr += 1;

	let nibble_offset = rlp_list.offset[cur_nibble as Field];

    let mut resolved_key = [0; KEY_LENGTH];
    
    for j in 0..KEY_LENGTH
	{
		resolved_key[j] = node[nibble_offset + j];
	}


    let out = (resolved_key, resolved_key_length, key_ptr);

    out
}

// Resolve a 2-node, i.e. a LEAF or EXTENSION.
fn resolve2<N, VALUE_LEN>(
    node_type: comptime Field,
    node: [u8; N],
    rlp_list: rlp::RLP_List<MAX_NUM_FIELDS>,
    key: [u4; NIBBLE_LENGTH],
    mut key_ptr: Field)
                      -> (
    [u8; VALUE_LEN], // Value
    Field, // Value length
    Field) // New key offset
{
    // We should be dealing with a node containing two elements
    assert(rlp_list.num_fields == 2);
    
    let mut value = [0; VALUE_LEN];
    
    let first_slot: [u8; 1 + NIBBLE_LENGTH/2] = rlp::take_dot_drop(node,rlp_list.offset[0]); // TODO: Replace consts with numeric generics when it is possible to use them in array length expressions
    
	let (nib, niblen): ([u4; NIBBLE_LENGTH], Field) = compact_decode(first_slot, rlp_list.length[0]);

    // Length checks.
    // Should not go past 64 nibbles.
	assert(((NIBBLE_LENGTH - key_ptr) as u32) >= niblen as u32);

    // Check that the `niblen` nibbles in the first slot match up with the `niblen` nibbles
    // in `key` starting from offset `key_ptr`.
    for i in 0..NIBBLE_LENGTH
    {
        if (i as u32) < (niblen as u32)
        {
            assert(nib[i] == key[key_ptr + i]);
        }
    }

    // Store length of value obtained
	let value_length = rlp_list.length[1];
    // This should not exceed VALUE_LEN
    assert((value_length as u32) <= (VALUE_LEN as u32));
   
    // Increment offset
    key_ptr += niblen;

	// Store value
    assert(((rlp_list.offset[1] + VALUE_LEN) as u32) <= (N as u32)); // VALUE_LEN should be consistent with maximum node length
	for i in 0..VALUE_LEN
	{
		value[i] = node[rlp_list.offset[1] + i];
	}

    // Ensure we've followed the right kind of node, i.e. if we're not at the end of the key,
    // we should have followed an extension node, and if we are, then we should have followed a leaf node.
    let node_type_nibble = (first_slot[0] >> 4);

    assert(if node_type == LEAF { (node_type_nibble as u4) > 1 } else { (node_type == EXTENSION) & ((node_type_nibble as u4) <= 1) }); // Must have resolved a leaf or extension node.
    
    (value, value_length, key_ptr)
}


fn right_align_bytes<N>(arr: [u8; N], len: Field) -> [u8; N]
{
    assert((len as u32) < (N as u32));

    let mut out = [0; N];
    
    let offset = N - len;

    for i in 0..N
    {
        if (i as u32) >= (offset as u32)
        {
            out[i] = arr[i - offset];
        }
    }

    out
}

// Function taking a left-padded byte array representing an integer and returning a right-padded one
// together with its byte length.
fn byte_value<N>(in_value: [u8; N]) -> ([u8; N], Field)
{
    let mut value_length = 0;

    for i in 0..N
    {
        let num_bytes_p = (value_length == 0) as Field;
        let byte_p = (in_value[i] != 0) as Field;
        value_length = num_bytes_p*byte_p*(N - i) + (1-num_bytes_p)*value_length;
    }

    let value = left_byte_shift(in_value, N - value_length);

    (value, value_length)
}

fn left_byte_shift<N>(input: [u8; N], n: Field) -> [u8; N]
{
    let mut out = [0; N];

    for i in 0..N
    {
        if ((i + n) as u32) < (N as u32)
        {
            out[i] = input[i+n];
        }
    }

    out
}

fn first_n_bytes_eq<N>(arr1: [u8; N], arr2: [u8; N], n: Field) -> bool
{
    for i in 0..N
    {
        let range_p = (i as u32) < (n as u32);

        assert(!range_p | (arr1[i] == arr2[i]));
    }
    
    true
}

#[test]
fn byte_value_test()
{
    let test0 = byte_value([0,0,0,1,2,3]);
    assert((test0.0 == [1,2,3,0,0,0]) & (test0.1 == 3));

    let test1 = byte_value([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,0,0,0]);
    assert((test1.0 == [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,0,0,0]) & (test1.1 == 32));

    let test2 = byte_value([0,0,0,0,0,0,0,0,0,0,11,12,13,14,15,16,17,18,19,20,0,0,0,0,0,0,0,0,0,0,0,0]);
    assert((test2.0 == [11,12,13,14,15,16,17,18,19,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]) & (test2.1 == 22));
}

// Trie proof tests
#[test]
fn cryptopunk1_state()
{
    // Obtain state root using
    // curl -X POST https://rpc.ankr.com/eth -d '{"jsonrpc":"2.0","method":"eth_getBlockByNumber","params":["latest", false],"id":1}'
    // ...and fetch account proof using
    // curl -X POST https://rpc.ankr.com/eth -d '{"jsonrpc":"2.0","method":"eth_getProof","params":["0xb47e3cd837dDF8e4c57f05d70ab865de6e193bbb",["0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc7"],"latest"],"id":1}'
    let path = [249,2,17,160,35,17,79,185,138,159,91,176,132,186,80,227,239,85,212,169,208,213,4,59,44,181,132,141,59,188,97,187,173,87,205,62,160,82,254,213,162,141,227,42,246,119,7,137,227,56,151,16,189,182,19,121,233,179,150,139,45,248,54,90,14,224,0,60,167,160,48,8,63,123,85,244,40,162,211,136,166,101,5,247,142,67,21,126,64,162,189,139,88,111,66,230,247,96,232,158,75,205,160,155,73,39,219,154,141,139,233,149,57,230,123,68,79,89,232,39,164,81,108,199,182,110,215,164,224,114,69,110,234,221,7,160,190,245,36,184,92,249,156,91,200,252,182,85,234,142,154,203,206,67,66,244,74,200,73,70,46,203,40,162,107,126,98,213,160,101,35,218,208,126,244,41,228,166,159,174,100,253,108,246,170,253,166,220,122,90,227,86,222,144,182,224,239,134,211,233,30,160,33,11,116,243,129,168,55,77,4,251,38,35,92,76,1,161,174,135,43,118,1,5,19,231,161,48,60,244,192,229,173,73,160,46,233,6,120,179,119,250,188,223,146,42,46,203,151,66,90,113,203,237,65,48,106,187,97,152,244,96,220,26,29,46,205,160,252,183,216,206,254,146,249,143,227,127,225,171,42,40,64,121,170,234,114,184,249,205,22,178,14,244,101,147,246,240,131,220,160,133,207,108,238,250,153,232,210,157,190,153,186,148,234,183,199,42,230,27,53,11,242,181,12,217,19,38,191,83,218,61,116,160,244,4,193,45,74,90,26,10,10,236,166,144,158,152,151,234,21,31,245,251,158,215,106,99,29,72,144,137,79,167,200,132,160,139,191,113,131,112,160,56,247,45,238,222,100,98,158,35,234,140,218,170,253,134,133,144,204,237,52,200,187,193,188,5,51,160,220,140,14,18,154,135,218,39,139,200,173,103,212,230,178,177,1,3,159,81,63,57,93,172,126,229,159,108,241,154,220,111,160,0,228,29,207,250,113,204,65,28,211,212,43,167,102,234,69,142,30,195,204,134,204,166,163,30,93,198,231,94,99,230,162,160,129,177,76,159,215,163,198,221,140,43,239,100,72,208,99,238,200,44,71,97,61,51,24,164,94,45,47,111,97,248,96,107,160,67,1,130,85,16,57,145,122,4,122,60,224,24,75,138,122,102,9,193,109,188,46,231,172,36,188,116,136,190,27,12,172,128,249,2,17,160,88,34,103,150,102,139,26,25,95,158,35,57,199,223,180,86,137,168,33,124,231,25,240,239,130,131,174,123,8,1,200,205,160,110,247,204,209,194,140,255,151,137,71,222,19,225,13,5,144,145,35,213,208,145,109,101,2,78,180,212,73,190,197,119,190,160,200,87,101,169,163,4,39,237,143,156,252,174,172,92,61,207,112,141,8,232,189,3,219,158,103,113,151,79,134,236,241,169,160,80,29,166,57,155,240,70,202,216,130,8,218,157,217,29,176,204,132,243,165,245,236,28,126,37,229,11,124,46,127,47,18,160,56,53,61,110,151,70,43,81,20,71,120,174,65,117,249,83,50,193,206,165,59,99,84,177,29,59,10,199,65,166,250,140,160,227,92,16,90,167,210,190,156,121,147,224,52,210,246,182,115,150,60,152,54,25,143,105,126,242,133,148,28,187,6,102,144,160,247,121,234,132,84,141,95,242,147,166,130,188,49,49,87,52,65,85,22,101,117,103,245,150,19,221,60,117,161,130,179,235,160,206,152,11,133,171,121,125,76,192,21,89,205,125,28,223,159,134,156,187,204,2,27,164,218,204,63,133,198,210,221,121,99,160,64,208,55,19,3,190,137,166,255,230,44,11,54,154,187,102,148,38,8,193,93,122,85,43,24,117,252,59,56,136,200,225,160,133,210,230,131,115,181,109,75,185,27,251,30,29,105,98,198,77,221,3,17,178,32,90,103,2,243,226,175,69,202,130,215,160,229,82,36,231,17,120,69,119,115,89,157,201,88,234,225,226,114,133,247,253,73,66,94,29,170,152,239,77,64,144,1,121,160,97,97,44,138,181,60,113,164,65,44,54,4,132,22,85,98,159,194,253,204,49,160,9,187,40,167,139,73,36,102,120,211,160,183,174,54,76,40,96,115,213,244,78,246,21,195,137,48,229,124,211,73,136,20,39,154,219,28,237,237,220,240,125,159,205,160,112,249,242,227,25,6,172,196,90,145,140,159,247,143,96,188,32,125,186,24,163,23,2,177,176,229,178,130,90,187,9,176,160,222,237,236,16,5,212,103,235,63,220,22,187,22,57,90,30,178,199,1,202,250,25,89,196,116,221,164,144,13,168,94,1,160,41,10,21,78,52,1,70,97,185,70,130,82,149,203,160,59,37,246,96,60,188,210,244,199,163,130,84,36,242,121,118,63,128,249,2,17,160,103,161,177,28,26,188,233,187,156,187,249,72,183,31,164,199,123,123,29,214,161,175,94,64,142,60,225,196,133,243,48,20,160,138,249,253,88,190,108,89,149,183,17,193,115,12,152,6,170,205,232,132,26,44,108,14,191,129,156,127,175,96,118,84,122,160,218,148,48,72,150,130,102,21,190,5,254,93,209,85,243,109,189,170,69,172,52,6,136,43,254,218,123,59,72,255,72,77,160,21,243,124,79,180,9,19,147,241,240,218,54,111,141,78,163,17,211,62,89,202,63,59,17,157,4,82,31,194,224,160,160,160,233,241,142,161,68,123,180,66,84,160,52,0,99,230,203,175,227,39,168,113,5,225,3,170,6,86,247,112,14,23,137,183,160,5,54,15,34,223,229,10,224,73,52,208,132,112,138,196,86,158,201,44,106,140,220,180,170,47,157,221,213,105,214,119,49,160,238,74,53,191,246,114,235,101,14,194,181,85,31,203,186,67,75,15,101,202,0,177,105,123,246,239,106,9,116,208,199,234,160,218,248,254,61,209,17,51,75,33,121,104,242,151,128,95,32,99,171,33,64,214,98,189,123,107,110,54,64,82,139,195,76,160,123,242,38,151,209,20,182,216,139,59,200,254,242,192,252,5,168,192,34,208,94,211,65,29,1,82,255,128,77,64,64,27,160,200,167,41,9,249,186,188,81,164,220,254,140,203,68,114,5,246,85,56,124,114,154,132,144,100,79,29,63,145,201,87,28,160,40,31,22,37,46,228,181,48,214,101,231,58,72,27,12,160,149,97,150,245,17,242,232,45,207,135,129,70,50,33,72,230,160,158,148,190,168,74,145,98,108,105,213,173,201,60,220,164,224,200,146,255,26,203,56,3,151,212,152,202,29,223,160,223,4,160,24,96,134,2,138,4,233,32,161,172,249,255,45,45,235,241,34,33,128,183,24,125,5,115,78,24,32,55,35,196,99,231,160,101,88,39,246,121,232,41,207,1,208,113,34,158,3,39,1,255,32,135,128,72,202,66,59,162,82,6,55,0,185,62,65,160,150,27,5,99,67,185,125,81,73,29,125,106,52,204,33,118,136,42,227,106,11,139,83,237,58,248,137,6,152,250,216,113,160,245,122,205,240,103,72,229,66,78,200,176,223,216,33,233,66,219,85,6,87,33,88,230,212,245,13,68,91,82,144,173,12,128,249,2,17,160,156,148,137,159,109,37,239,242,22,87,171,170,35,223,120,66,94,156,3,126,83,114,98,94,204,13,108,95,185,58,68,208,160,14,226,175,21,183,246,168,248,83,114,152,151,103,154,115,114,246,73,88,187,195,169,111,181,188,210,176,28,145,209,202,234,160,128,143,71,9,112,24,135,242,221,118,3,179,152,135,103,132,140,4,9,146,27,143,195,202,46,246,128,141,204,229,12,18,160,28,60,69,129,47,178,137,115,234,254,191,167,245,215,246,42,165,77,209,114,123,128,61,228,165,230,240,232,2,96,177,66,160,112,54,58,251,78,152,230,125,42,228,43,232,215,14,122,206,36,35,206,165,218,250,74,69,28,190,245,218,173,249,85,36,160,227,142,197,139,149,226,64,190,81,208,166,123,242,85,208,55,236,76,16,148,35,157,51,171,152,248,165,140,138,68,172,243,160,53,55,24,200,20,143,149,163,128,225,126,16,204,7,37,212,44,82,108,99,158,245,26,234,173,154,125,93,240,178,129,11,160,222,99,144,74,121,69,21,245,234,67,21,125,138,0,60,246,49,111,17,11,30,218,209,243,71,180,223,152,11,59,228,97,160,195,124,229,231,229,5,172,89,57,254,172,102,42,229,35,189,103,97,38,27,103,150,41,204,131,100,222,233,60,132,232,222,160,149,220,49,59,105,88,216,43,76,167,141,65,22,92,35,152,122,8,31,49,75,11,215,175,180,167,105,226,6,167,162,141,160,156,122,248,193,14,90,205,42,196,147,86,50,158,129,147,91,56,93,249,48,184,30,183,210,201,137,199,46,158,217,195,153,160,247,169,39,249,65,209,177,174,214,202,205,50,240,133,144,70,218,83,201,203,191,224,174,194,72,157,18,162,164,118,65,152,160,152,78,0,177,23,81,163,214,160,65,201,131,152,209,122,85,148,128,0,143,44,174,61,100,198,107,171,166,27,66,99,121,160,252,225,1,170,141,56,106,212,124,197,192,88,0,43,151,100,160,6,193,201,101,57,68,149,104,253,154,157,206,183,102,37,160,42,220,33,172,139,185,40,133,117,8,109,151,129,135,29,147,161,38,58,233,32,252,17,240,213,38,255,167,12,75,192,73,160,61,22,114,156,249,75,96,160,191,130,96,174,203,8,51,143,149,188,150,88,4,77,17,86,137,5,11,227,88,102,90,69,128,249,2,17,160,243,16,156,60,198,156,88,19,115,173,180,133,195,42,213,170,192,91,172,24,183,157,73,229,20,206,22,102,120,100,100,238,160,242,165,4,101,129,70,244,113,154,107,193,141,223,175,147,241,81,166,16,88,246,163,192,110,140,198,161,235,150,88,181,7,160,111,34,154,163,81,184,217,114,140,79,210,171,75,207,137,142,28,216,221,122,93,149,72,104,14,25,200,225,82,243,188,119,160,7,54,62,182,221,15,145,115,97,140,27,152,78,253,32,14,159,248,248,215,153,188,207,149,172,107,66,49,200,211,67,235,160,87,31,178,195,7,45,211,93,208,139,120,76,5,47,190,227,247,197,164,2,124,86,116,123,152,76,219,110,179,182,233,41,160,29,238,220,129,252,183,202,32,199,197,113,63,138,157,89,242,168,133,56,218,96,102,213,128,238,195,179,23,96,59,168,18,160,48,39,52,47,236,231,164,176,217,95,23,86,254,76,43,57,49,163,210,129,221,120,150,109,175,216,54,175,83,142,42,147,160,167,86,178,140,2,41,178,19,38,183,114,221,73,134,125,192,186,75,113,244,188,114,173,110,21,174,136,153,21,144,204,200,160,20,138,36,98,232,165,219,172,185,44,5,63,215,10,225,157,16,143,44,200,65,27,166,85,21,55,212,19,40,52,150,224,160,25,52,36,63,74,90,37,255,25,112,68,70,219,196,187,78,127,245,243,172,165,74,59,123,107,24,83,44,66,192,223,10,160,222,123,255,116,170,198,167,126,148,244,253,43,26,44,176,168,11,213,250,112,231,244,199,101,239,76,48,167,97,160,48,93,160,126,143,190,212,161,239,23,53,235,57,194,170,136,78,236,11,138,177,242,112,26,1,8,175,68,218,216,143,84,47,24,187,160,62,158,33,65,131,139,137,105,167,93,94,27,151,233,11,36,94,207,205,248,191,25,114,251,101,240,5,66,101,158,68,195,160,59,125,140,59,213,211,138,199,135,139,93,101,229,6,182,17,187,125,160,214,170,250,80,210,183,127,121,186,50,177,22,183,160,67,42,78,158,135,183,37,231,51,151,196,242,44,36,206,254,28,42,87,151,7,251,215,41,139,72,28,253,76,218,25,158,160,21,245,35,13,241,185,105,125,47,61,0,241,9,209,116,87,225,250,112,25,122,235,155,186,216,107,36,48,134,150,26,52,128,249,2,17,160,115,20,231,212,152,98,211,129,72,227,76,19,250,54,197,235,226,66,21,159,57,72,152,10,167,59,158,112,251,134,39,77,160,252,101,54,110,124,80,140,98,48,251,168,226,14,130,154,78,155,120,81,35,69,165,104,183,147,90,148,50,171,94,242,15,160,175,11,24,143,24,188,231,73,147,188,170,75,162,211,14,121,1,84,242,159,228,147,188,71,20,4,183,137,106,255,33,224,160,240,35,225,62,138,142,179,80,79,233,60,83,124,247,95,106,80,24,23,188,151,232,14,125,204,229,47,225,14,101,15,111,160,2,148,192,151,232,233,140,133,199,166,1,248,65,44,197,198,97,221,55,57,35,180,182,172,78,90,126,5,168,100,107,246,160,15,147,81,67,234,238,219,73,83,26,242,7,46,146,127,60,91,130,95,56,121,173,45,6,83,171,146,210,5,103,48,18,160,58,206,231,64,221,55,121,192,72,176,160,234,173,33,210,121,175,129,71,158,172,35,85,188,53,8,107,252,187,41,78,64,160,226,166,86,21,64,29,149,83,235,139,79,66,9,82,196,18,50,91,161,245,2,102,207,105,70,2,211,96,99,194,172,180,160,93,11,236,214,2,112,13,10,228,142,16,244,169,126,29,153,55,60,25,180,86,44,150,230,211,210,155,45,3,83,143,219,160,161,245,213,13,84,188,201,181,231,185,33,94,220,35,155,196,221,1,236,114,1,208,188,161,230,61,72,91,176,159,77,220,160,119,140,117,124,1,37,152,69,34,232,11,142,171,0,13,198,4,216,104,102,6,82,135,134,37,75,22,251,162,223,139,50,160,82,214,243,155,213,117,93,4,215,28,97,215,178,114,184,127,245,188,220,183,221,178,85,30,235,245,80,209,53,106,219,108,160,117,73,250,20,108,233,125,57,166,40,69,227,149,216,244,88,64,206,161,183,249,72,222,239,37,171,86,224,37,112,156,216,160,196,28,140,174,232,227,217,179,9,87,184,195,67,44,121,241,236,19,125,128,123,91,79,199,10,90,108,82,32,247,70,66,160,93,123,139,216,185,254,68,47,38,206,125,228,31,103,114,214,251,87,38,86,17,17,247,28,22,161,106,20,228,181,178,17,160,197,131,246,182,35,231,187,170,229,129,201,77,197,99,223,138,63,105,90,254,77,21,226,98,198,63,6,204,168,90,144,151,128,249,1,17,128,128,160,181,97,232,88,66,17,18,35,3,143,215,239,40,90,191,138,243,72,211,244,159,219,42,74,106,25,118,240,160,119,80,105,160,234,98,171,93,187,172,62,5,38,128,89,224,209,164,129,90,20,61,240,191,15,26,183,186,83,42,58,37,66,11,254,15,160,96,225,198,195,140,205,201,110,250,239,125,190,22,27,158,97,43,64,19,1,78,92,198,96,160,180,205,34,64,36,224,31,128,128,160,148,190,54,26,158,232,77,165,166,153,183,126,156,153,157,222,72,80,163,26,13,208,25,19,10,57,6,19,72,28,54,228,160,107,158,152,156,242,159,119,188,69,88,76,138,214,139,31,148,197,67,186,238,138,27,15,17,15,82,134,130,129,123,13,149,128,160,242,136,37,46,84,217,167,241,4,107,217,154,69,129,166,248,161,219,17,56,33,59,210,115,73,4,118,88,77,107,19,227,160,127,99,186,184,188,30,186,217,4,229,71,62,203,180,184,121,75,158,34,163,30,82,176,243,129,182,216,144,24,196,66,33,160,62,113,155,138,140,159,169,35,227,191,166,57,200,50,150,114,86,163,83,46,242,62,74,48,114,4,81,12,168,194,207,241,128,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,112,157,63,140,127,171,87,71,26,42,65,56,127,155,13,14,171,34,148,87,197,2,75,214,207,183,45,215,187,162,254,184,80,248,78,1,138,1,9,138,94,49,250,197,178,237,53,160,59,53,98,31,248,199,239,241,97,151,191,214,41,112,208,186,6,39,251,176,77,96,206,86,100,69,139,103,53,252,45,68,160,226,231,167,82,74,152,206,98,158,228,6,193,92,81,166,131,228,22,127,11,116,234,35,5,102,221,236,231,174,157,111,11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let depth = 8;
    let key = [0xb4,0x7e,0x3c,0xd8,0x37,0xdD,0xF8,0xe4,0xc5,0x7f,0x05,0xd7,0x0a,0xb8,0x65,0xde,0x6e,0x19,0x3b,0xbb];
    let value = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,78,1,138,1,9,138,94,49,250,197,178,237,53,160,59,53,98,31,248,199,239,241,97,151,191,214,41,112,208,186,6,39,251,176,77,96,206,86,100,69,139,103,53,252,45,68,160,226,231,167,82,74,152,206,98,158,228,6,193,92,81,166,131,228,22,127,11,116,234,35,5,102,221,236,231,174,157,111,11];
    let state_root = [112,56,122,133,23,47,73,128,191,60,87,177,86,13,219,71,223,227,99,198,112,59,153,131,186,191,11,171,14,118,189,34];

    let trie_proof = TrieProof
    {
        key,
        proof: path,
        depth,
        value
    };
    assert(trie_proof.verify_state_root(state_root));
}

#[test]
fn cryptopunk1() // Who owns the first cryptopunk? cf. https://www.youtube.com/watch?v=2-yYtEJdrFY&t=266s
{
    // Block 14194126
    // Address: 0xb47e3cd837dDF8e4c57f05d70ab865de6e193bbb
    // Value: 0xb88f61e6fbda83fbfffabe364112137480398018
    // Key: 0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc7
    // Fetch proof using e.g.
    // curl -X POST https://rpc.ankr.com/eth -d '{"jsonrpc":"2.0","method":"eth_getProof","params":["0xb47e3cd837dDF8e4c57f05d70ab865de6e193bbb",["0xbbc70db1b6c7afd11e79c0fb0051300458f1a3acb8ee9789d9b6b26c61ad9bc7"],"latest"],"id":1}'

    let path = [249,2,17,160,131,222,227,85,174,97,156,127,191,169,123,140,230,159,249,132,240,154,181,243,84,51,151,47,88,26,53,171,190,213,205,185,160,229,63,170,108,2,183,41,202,254,50,239,181,218,135,195,8,21,100,37,42,62,117,201,80,140,169,199,152,187,0,30,191,160,169,218,185,94,14,107,53,100,115,116,135,137,188,18,95,207,182,185,56,177,139,5,118,44,30,206,202,84,53,126,44,109,160,188,117,50,13,5,219,241,132,23,179,73,107,238,66,145,170,27,62,178,71,145,173,76,216,31,42,126,67,46,40,234,65,160,56,185,158,70,248,209,40,213,179,137,41,131,155,77,64,164,242,169,24,242,168,49,36,168,79,130,172,138,98,13,141,14,160,194,18,203,128,147,53,23,137,77,219,80,157,139,57,233,39,114,219,144,69,52,96,79,131,146,232,68,222,89,91,235,162,160,191,212,103,121,255,198,244,86,229,4,9,218,180,94,131,235,106,220,183,95,3,82,104,60,111,20,115,172,183,18,202,35,160,200,204,47,138,125,135,230,115,9,24,170,45,75,88,181,173,229,247,16,111,237,182,167,60,205,19,217,68,86,241,161,214,160,194,1,45,132,217,242,127,219,118,58,85,225,67,139,98,169,99,60,242,186,130,120,131,160,215,14,62,65,101,165,53,167,160,175,200,34,123,178,141,77,67,228,252,69,109,200,60,27,28,0,178,219,252,91,47,100,195,190,128,45,196,5,96,98,183,160,198,132,64,192,40,105,95,204,180,173,60,217,197,191,249,205,67,33,193,246,11,167,81,184,138,106,156,33,143,239,250,56,160,67,164,81,196,212,211,46,230,53,153,22,28,81,97,239,230,159,240,109,143,248,243,21,116,109,48,142,250,75,118,104,115,160,189,194,208,247,5,235,15,199,194,91,157,121,242,245,193,1,169,118,195,215,51,197,2,222,79,15,67,98,185,239,123,173,160,40,250,181,145,247,42,198,42,104,245,191,66,0,67,152,247,12,220,163,19,95,216,163,14,97,48,13,67,44,92,252,125,160,251,1,134,193,15,46,176,143,28,66,178,148,103,88,37,164,69,155,75,67,194,70,248,28,196,201,10,68,122,0,135,105,160,160,29,82,173,191,137,225,140,77,68,120,88,139,209,23,23,251,22,129,148,136,139,141,212,100,44,198,38,46,217,60,158,128,249,2,17,160,240,221,35,192,34,64,110,48,186,9,130,70,201,43,141,190,210,216,91,87,72,214,144,194,248,64,64,165,141,112,22,179,160,166,50,206,215,247,106,66,47,103,45,150,112,167,63,103,59,63,177,111,129,155,67,152,164,19,6,141,199,2,164,247,202,160,100,236,241,61,41,155,249,81,182,64,34,225,46,220,31,63,90,151,91,255,29,193,58,49,109,235,56,21,246,58,16,99,160,70,150,205,16,82,199,200,205,61,182,26,145,171,110,131,203,246,170,7,243,203,79,216,227,112,159,0,186,82,36,72,59,160,123,39,110,202,80,98,63,47,27,111,158,103,65,133,212,175,165,156,96,80,186,88,234,82,148,145,190,103,90,130,38,21,160,33,20,100,92,250,63,113,203,209,194,23,188,13,237,219,69,43,123,120,12,79,133,79,161,120,185,84,118,7,251,132,16,160,249,84,201,100,25,202,200,41,6,211,118,40,122,59,106,97,181,175,18,199,192,21,153,123,212,84,84,181,80,143,48,237,160,210,245,166,106,201,156,229,19,101,113,15,82,70,90,58,114,165,193,3,146,212,139,143,245,189,55,191,86,83,135,31,106,160,11,162,234,207,240,91,155,86,19,68,244,50,131,236,140,222,18,129,243,19,63,111,96,12,140,157,72,213,77,233,0,126,160,8,57,227,179,220,228,76,216,159,224,234,44,126,155,24,85,102,253,127,197,169,120,41,176,230,13,231,91,171,162,229,69,160,12,174,232,237,84,114,140,212,41,142,149,3,132,221,232,117,149,199,207,74,77,198,162,154,185,241,35,52,228,251,254,39,160,179,165,104,1,2,235,205,172,12,255,11,73,43,48,30,90,25,208,181,35,209,207,210,112,212,70,231,216,251,157,168,221,160,97,73,209,221,129,7,203,113,14,5,240,163,152,4,141,187,121,234,1,165,174,246,157,0,48,42,192,105,166,64,61,21,160,237,33,177,147,8,139,156,202,104,19,51,96,17,245,99,50,242,238,254,222,234,136,244,227,138,69,3,45,198,91,101,1,160,70,98,16,229,221,172,207,159,98,51,174,150,20,51,59,233,143,159,6,68,112,9,122,196,64,229,56,171,194,38,223,133,160,174,150,11,38,214,72,120,225,198,168,11,121,24,79,3,167,203,49,251,26,133,68,180,186,94,101,230,211,81,110,163,73,128,249,2,17,160,47,69,48,53,130,59,211,11,161,1,213,54,30,201,238,178,220,114,179,211,153,17,50,56,66,84,35,30,9,246,222,174,160,90,113,236,5,199,178,159,238,6,57,151,8,151,218,159,45,241,125,148,18,198,139,154,225,57,171,38,129,40,24,226,126,160,23,1,151,85,165,9,212,114,100,197,87,35,107,179,126,231,8,114,135,16,213,253,139,43,82,190,250,58,126,11,23,249,160,42,168,203,133,243,35,55,5,250,244,4,21,83,100,84,236,203,181,178,252,137,85,84,6,184,152,197,83,243,248,232,155,160,160,203,36,105,6,142,43,229,53,15,71,197,119,247,79,212,130,50,151,143,10,12,58,66,31,221,110,128,250,109,67,154,160,253,218,130,199,68,153,141,19,216,149,99,99,54,201,171,223,216,171,18,55,15,120,74,175,68,139,14,189,190,63,239,59,160,94,199,190,215,147,134,100,152,161,160,185,168,247,212,4,251,50,232,217,119,113,181,209,74,197,20,73,107,31,77,59,174,160,11,214,206,214,112,141,172,209,164,254,114,134,128,150,153,24,116,222,47,164,24,127,5,79,209,197,29,129,244,71,204,116,160,123,189,205,165,68,166,56,90,164,171,94,191,145,184,43,155,210,126,23,227,163,21,0,116,2,236,1,161,2,44,58,79,160,116,95,232,43,89,83,196,203,4,225,246,152,56,41,102,200,245,170,93,63,47,200,9,14,155,202,82,53,171,161,114,240,160,76,121,242,107,106,6,5,54,174,132,114,165,21,175,174,15,43,239,28,25,91,101,150,231,68,5,149,23,170,155,165,208,160,209,166,45,131,155,154,139,188,146,138,128,171,125,95,170,4,255,248,54,97,157,173,85,243,0,182,186,151,29,211,49,46,160,215,233,123,209,95,254,3,211,130,155,102,147,195,1,36,117,91,101,21,132,128,227,100,46,25,219,109,94,68,99,173,45,160,81,121,242,103,174,208,230,76,220,90,237,138,17,38,100,96,7,172,79,100,236,33,60,19,179,223,227,216,154,212,4,149,160,18,90,118,20,167,150,50,13,211,230,184,27,165,84,167,110,4,205,149,83,174,208,43,122,14,58,249,30,101,194,41,76,160,74,237,218,87,155,244,168,177,208,213,70,251,69,136,69,249,52,41,122,105,254,194,143,31,47,31,235,100,46,76,57,47,128,248,177,128,128,128,128,128,160,28,249,182,132,51,145,111,142,211,178,180,147,92,161,244,19,73,10,187,240,227,19,159,57,142,9,254,81,139,248,67,175,128,128,160,73,97,138,225,4,245,30,87,189,138,110,63,153,2,254,23,33,35,77,206,160,31,55,142,20,57,31,122,160,140,79,188,128,160,15,143,44,113,58,7,157,9,191,167,58,140,221,27,221,62,79,240,181,31,177,121,148,175,107,82,237,215,126,250,137,75,128,160,41,222,166,27,179,177,3,173,193,241,7,231,155,19,232,201,100,152,160,60,219,21,187,170,229,4,97,78,229,104,217,14,160,0,188,57,48,132,60,195,69,115,33,11,219,146,191,236,195,45,181,187,210,167,19,203,73,127,26,141,27,147,110,109,204,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,246,159,32,176,50,213,165,250,58,91,101,68,86,110,228,106,15,107,143,232,177,55,94,200,120,220,59,230,88,11,7,132,149,149,148,184,143,97,230,251,218,131,251,255,250,190,54,65,18,19,116,128,57,128,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
    let depth = 5; // Actual depth

    let storage_root = [0x91,0x1b,0xb4,0x34,0xb8,0x45,0x6f,0x99,0x79,0xf4,0x2a,0x4e,0x3b,0x0c,0x4d,0x00,0x25,0xee,0x93,0xc3,0xb1,0x2a,0xb7,0x97,0x41,0xf7,0x08,0x17,0x02,0x2d,0x08,0x0e];
    let trie_proof = TrieProof
    {
        key: [0xbb,0xc7,0x0d,0xb1,0xb6,0xc7,0xaf,0xd1,0x1e,0x79,0xc0,0xfb,0x00,0x51,0x30,0x04,0x58,0xf1,0xa3,0xac,0xb8,0xee,0x97,0x89,0xd9,0xb6,0xb2,0x6c,0x61,0xad,0x9b,0xc7],
        proof: path,
        depth: depth,
        value: [0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xb8,0x8f,0x61,0xe6,0xfb,0xda,0x83,0xfb,0xff,0xfa,0xbe,0x36,0x41,0x12,0x13,0x74,0x80,0x39,0x80,0x18]
    };
    assert(trie_proof.verify_storage_root(storage_root));

}

#[test]
fn nibble_check()
{
    assert(key_as_nibbles([0x56,0xe8,0x1f,0x17,0x1b,0xcc,0x55,0xa6,0xff,0x83,0x45,0xe6,0x92,0xc0,0xf8,0x6e,0x5b,0x48,0xe0,0x1b,0x99,0x6c,0xad,0xc0,0x01,0x62,0x2f,0xb5,0xe3,0x63,0xb4,0x21]) == [0x05,0x06,0x0e,0x08,0x01,0x0f,0x01,0x07,0x01,0x0b,0x0c,0x0c,0x05,0x05,0x0a,0x06,0x0f,0x0f,0x08,0x03,0x04,0x05,0x0e,0x06,0x09,0x02,0x0c,0x00,0x0f,0x08,0x06,0x0e,0x05,0x0b,0x04,0x08,0x0e,0x00,0x01,0x0b,0x09,0x09,0x06,0x0c,0x0a,0x0d,0x0c,0x00,0x00,0x01,0x06,0x02,0x02,0x0f,0x0b,0x05,0x0e,0x03,0x06,0x03,0x0b,0x04,0x02,0x01]);
}

#[test]
fn compact_decode_test()
{
    let (nibble0, len0): ([u4; NIBBLE_LENGTH], Field) = compact_decode([0x11, 0x23, 0x45,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 3);
    assert(len0 == 5);
    assert([nibble0[0], nibble0[1], nibble0[2], nibble0[3], nibble0[4]] == [1,2,3,4,5]);

    let (nibble1, len1): ([u4; NIBBLE_LENGTH], Field) = compact_decode([0x20, 0x0f, 0x1c, 0xb8, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 4);
    assert(len1 == 6);
    assert([nibble1[0], nibble1[1], nibble1[2], nibble1[3], nibble1[4], nibble1[5]] == [0,15,1,12,11,8]);

    let (nibble2, len2): ([u4; NIBBLE_LENGTH], Field) = compact_decode([0x3f, 0x1c, 0xb8, 0x99, 0xab, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 3);
    assert(len2 == 5);
    assert([nibble2[0], nibble2[1], nibble2[2], nibble2[3], nibble2[4]] == [15,1,12,11,8]);
    
}
